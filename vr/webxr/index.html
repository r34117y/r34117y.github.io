<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<p>https://developer.mozilla.org/en-US/docs/Web/API/WebXR_Device_API/Movement_and_motion</p>
<script>
    const xRotationDegreesPerSecond = 25;
    const yRotationDegreesPerSecond = 15;
    const zRotationDegreesPerSecond = 35;
    const enableRotation = true;
    const allowMouseRotation = true;
    const allowKeyboardMotion = true;
    const enableForcePolyfill = false;
    //const SESSION_TYPE = "immersive-vr";
    const SESSION_TYPE = "inline";
    const MOUSE_SPEED = 0.003;

    let polyfill = null;
    let xrSession = null;
    let xrInputSources = null;
    let xrReferenceSpace = null;
    let xrButton = null;
    let gl = null;
    let animationFrameRequestID = 0;
    let shaderProgram = null;
    let programInfo = null;
    let buffers = null;
    let texture = null;
    let mouseYaw = 0;
    let mousePitch = 0;

    const viewerStartPosition = vec3.fromValues(0, 0, -10);
    const viewerStartOrientation = vec3.fromValues(0, 0, 1.0);

    const cubeOrientation = vec3.create();
    const cubeMatrix = mat4.create();
    const mouseMatrix = mat4.create();
    const inverseOrientation = quat.create();
    const RADIANS_PER_DEGREE = Math.PI / 180.0;

    function LogGLError(where) {
        let err = gl.getError();
        if (err) {
            console.error(`WebGL error returned by ${where}: ${err}`);
        }
    }

    window.addEventListener("load", onLoad);

    function onLoad() {
        xrButton = document.querySelector("#enter-xr");
        xrButton.addEventListener("click", onXRButtonClick);

        projectionMatrixOut = document.querySelector("#projection-matrix div");
        modelMatrixOut = document.querySelector("#model-view-matrix div");
        cameraMatrixOut = document.querySelector("#camera-matrix div");
        mouseMatrixOut = document.querySelector("#mouse-matrix div");

        if (!navigator.xr || enableForcePolyfill) {
            console.log("Using the polyfill");
            polyfill = new WebXRPolyfill();
        }
        setupXRButton();
    }

    function setupXRButton() {
        if (navigator.xr.isSessionSupported) {
            navigator.xr.isSessionSupported(SESSION_TYPE)
                .then((supported) => {
                    xrButton.disabled = !supported;
                });
        } else {
            navigator.xr.supportsSession(SESSION_TYPE)
                .then(() => {
                    xrButton.disabled = false;
                })
                .catch(() => {
                    xrButton.disabled = true;
                });
        }
    }

    async function onXRButtonClick(event) {
        if (!xrSession) {
            navigator.xr.requestSession(SESSION_TYPE)
                .then(sessionStarted);
        } else {
            await xrSession.end();

            if (xrSession) {
                sessionEnded();
            }
        }
    }

    function sessionStarted(session) {
        let refSpaceType;

        xrSession = session;
        xrButton.innerText = "Exit WebXR";
        xrSession.addEventListener("end", sessionEnded);

        let canvas = document.querySelector("canvas");
        gl = canvas.getContext("webgl", { xrCompatible: true });

        if (allowMouseRotation) {
            canvas.addEventListener("pointermove", handlePointerMove);
            canvas.addEventListener("contextmenu", (event) => { event.preventDefault(); });
        }

        if (allowKeyboardMotion) {
            document.addEventListener("keydown", handleKeyDown);
        }

        shaderProgram = initShaderProgram(gl, vsSource, fsSource);

        programInfo = {
            program: shaderProgram,
            attribLocations: {
                vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                vertexNormal: gl.getAttribLocation(shaderProgram, 'aVertexNormal'),
                textureCoord: gl.getAttribLocation(shaderProgram, 'aTextureCoord'),
            },
            uniformLocations: {
                projectionMatrix: gl.getUniformLocation(shaderProgram, 'uProjectionMatrix'),
                modelViewMatrix: gl.getUniformLocation(shaderProgram, 'uModelViewMatrix'),
                normalMatrix: gl.getUniformLocation(shaderProgram, 'uNormalMatrix'),
                uSampler: gl.getUniformLocation(shaderProgram, 'uSampler')
            },
        };

        buffers = initBuffers(gl);
        texture = loadTexture(gl, 'https://cdn.glitch.com/a9381af1-18a9-495e-ad01-afddfd15d000%2Ffirefox-logo-solid.png?v=1575659351244');

        xrSession.updateRenderState({
            baseLayer: new XRWebGLLayer(xrSession, gl)
        });

        if (SESSION_TYPE === "immersive-vr") {
            refSpaceType = "local";
        } else {
            refSpaceType = "viewer";
        }

        mat4.fromTranslation(cubeMatrix, viewerStartPosition);

        vec3.copy(cubeOrientation, viewerStartOrientation);

        xrSession.requestReferenceSpace(refSpaceType)
            .then((refSpace) => {
                xrReferenceSpace = refSpace.getOffsetReferenceSpace(
                    new XRRigidTransform(viewerStartPosition, cubeOrientation));
                animationFrameRequestID = xrSession.requestAnimationFrame(drawFrame);
            });

        return xrSession;
    }

    function sessionEnded() {
        xrButton.innerText = "Enter WebXR";

        if (animationFrameRequestID) {
            xrSession.cancelAnimationFrame(animationFrameRequestID);
            animationFrameRequestID = 0;
        }
        xrSession = null;
    }

    function handleKeyDown(event) {
        switch(event.key) {
            case "w":
            case "W":
                verticalDistance -= MOVE_DISTANCE;
                break;
            case "s":
            case "S":
                verticalDistance += MOVE_DISTANCE;
                break;
            case "a":
            case "A":
                transverseDistance += MOVE_DISTANCE;
                break;
            case "d":
            case "D":
                transverseDistance -= MOVE_DISTANCE;
                break;
            case "ArrowUp":
                axialDistance += MOVE_DISTANCE;
                break;
            case "ArrowDown":
                axialDistance -= MOVE_DISTANCE;
                break;
            case "r":
            case "R":
                transverseDistance = axialDistance = verticalDistance = 0;
                mouseYaw = mousePitch = 0;
                break;
            default:
                break;
        }
    }

    function handlePointerMove(event) {
        if (event.buttons & 2) {
            rotateViewBy(event.movementX, event.movementY);
        }
    }

    function rotateViewBy(dx, dy) {
        mouseYaw -= dx * MOUSE_SPEED;
        mousePitch -= dy * MOUSE_SPEED;

        if (mousePitch < -Math.PI * 0.5) {
            mousePitch = -Math.PI * 0.5;
        } else if (mousePitch > Math.PI * 0.5) {
            mousePitch = Math.PI * 0.5;
        }
    }

    let lastFrameTime = 0;

    function drawFrame(time, frame) {
        let session = frame.session;
        let adjustedRefSpace = xrReferenceSpace;
        let pose = null;

        animationFrameRequestID = session.requestAnimationFrame(drawFrame);
        adjustedRefSpace = applyViewerControls(xrReferenceSpace);
        pose = frame.getViewerPose(adjustedRefSpace);

        if (pose) {
            let glLayer = session.renderState.baseLayer;

            gl.bindFramebuffer(gl.FRAMEBUFFER, glLayer.framebuffer);
            LogGLError("bindFrameBuffer");

            gl.clearColor(0, 0, 0, 1.0);
            gl.clearDepth(1.0);                 // Clear everything
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            LogGLError("glClear");

            const deltaTime = (time - lastFrameTime) * 0.001;  // Convert to seconds
            lastFrameTime = time;

            for (let view of pose.views) {
                let viewport = glLayer.getViewport(view);
                gl.viewport(viewport.x, viewport.y, viewport.width, viewport.height);
                LogGLError(`Setting viewport for eye: ${view.eye}`);
                gl.canvas.width = viewport.width * pose.views.length;
                gl.canvas.height = viewport.height;
                renderScene(gl, view, programInfo, buffers, texture, deltaTime);
            }
        }
    }
</script>
</body>
</html>